# D2

## 1204. [S/W 문제해결 기본] 1일차 - 최빈수 구하기

어느 고등학교에서 실시한 1000명의 수학 성적을 토대로 통계 자료를 만들려고 한다.

이때, 이 학교에서는 최빈수를 이용하여 학생들의 평균 수준을 짐작하는데, 여기서 최빈수는 특정 자료에서 가장 여러 번 나타나는 값을 의미한다.

다음과 같은 수 분포가 있으면,

10, 8, 7, 2, 2, 4, 8, 8, 8, 9, 5, 5, 3

최빈수는 8이 된다.

최빈수를 출력하는 프로그램을 작성하여라 (단, 최빈수가 여러 개 일 때에는 가장 큰 점수를 출력하라).

**[제약 사항]**

학생의 수는 1000명이며, 각 학생의 점수는 0점 이상 100점 이하의 값이다.

**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 줄에는 테스트 케이스의 번호가 주어지고 그 다음 줄부터는 점수가 주어진다.

**[출력]**

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답을 출력한다.

```python
T = int(input())

i = 0 
db = []
while i < T:
    i += 1
    tc = int(input())

    scores = list(map(int, input().split()))
    db.append(scores)

for idx, score_list in enumerate(db):
    count_dict = {key: 0 for key in set(score_list)}
    for score in score_list:
        count_dict[score] += 1
    dic_max = max(count_dict.values())
    for key, value in count_dict.items():
        if value == dic_max:
            print(f'#{idx+1} {key}')
```

```
# input
10
1
<학생 1000명의 점수> 예: 41 85 72 38 80 69 65 ...
2
<학생 1000명의 점수>...
...

# output
#1 71
#2 76
.......
```



## 1284. 수도 요금 경쟁

삼성전자에 입사한 종민이는 회사 근처로 이사를 하게 되었다.

그런데 집의 위치가 두 수도 회사 A, B 중간에 위치하기에 원하는 수도 회사를 선택할 수 있게 되었는데, 두 회사 중 더 적게 수도 요금을 부담해도 되는 회사를 고르려고 한다.
 
종민이가 알아본 결과 두 회사의 수도 요금은 한 달 동안 사용한 수도의 양에 따라 다음과 같이 정해진다.
 
A사 : 1리터당 P원의 돈을 내야 한다.

B사 : 기본 요금이 Q원이고, 월간 사용량이 R리터 이하인 경우 요금은 기본 요금만 청구된다. 하지만 R 리터보다 많은 양을 사용한 경우 초과량에 대해 1리터당 S원의 요금을 더 내야 한다.

![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV2cT1EqARsBBASw)

종민이의 집에서 한 달간 사용하는 수도의 양이 W리터라고 할 때, 요금이 더 저렴한 회사를 골라 그 요금을 출력하는 프로그램을 작성하라.

**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스마다 첫 번째 줄에 위 본문에서 설명한 대로 P, Q, R, S, W(1 ≤ P, Q, R, S, W ≤ 10000, 자연수)가 순서대로 공백 하나로 구분되어 주어진다.

**[출력]**

각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 종민이가 내야 하는 수도 요금을 출력한다.

```python
T = int(input())

i = 0

a_comp = []
b_comp = []
while i < T:
    P, Q, R, S, W = map(int, input().split())
    i += 1
    a_comp.append(P * W)
    if R >= W:
        b_comp.append(Q)
    else:
        b_comp.append(Q + ((W - R) * S))

for tc in range(T):
    if a_comp[tc] > b_comp[tc]:
        print(f'#{tc+1} {b_comp[tc]}')
    else:
        print(f'#{tc+1} {a_comp[tc]}')
```

```
# input
2
9 100 20 3 10
8 300 100 10 250

# output
#1 90
#2 1800
```



## 1288. 새로운 불면증 치료법

민석이는 불면증에 걸렸다. 그래서 잠이 안 올 때의 민간요법 중 하나인 양 세기를 하려고 한다.

민석이는 1번 양부터 순서대로 세는 것이 재미없을 것 같아서 N의 배수 번호인 양을 세기로 하였다.

즉, 첫 번째에는 N번 양을 세고, 두 번째에는 2N번 양, … , k번째에는 kN번 양을 센다.

이렇게 숫자를 세던 민석이에게 잠은 더 오지 않고 다음과 같은 궁금증이 생겼다.

이전에 셌던 번호들의 각 자리수에서 0에서 9까지의 모든 숫자를 보는 것은 최소 몇 번 양을 센 시점일까?

예를 들어 N = 1295이라고 하자.

첫 번째로 N = 1295번 양을 센다. 현재 본 숫자는 1, 2, 5, 9이다.

두 번째로 2N = 2590번 양을 센다. 현재 본 숫자는 0, 2, 5, 9이다.

현재까지 본 숫자는 0, 1, 2, 5, 9이다.

세 번째로 3N = 3885번 양을 센다. 현재 본 숫자는 3, 5, 8이다.

현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.

네 번째로 4N = 5180번 양을 센다. 현재 본 숫자는 0, 1, 5, 8이다.

현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.

다섯 번째로 5N = 6475번 양을 센다. 현재 본 숫자는 4, 5, 6, 7이다.

현재까지 본 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9이다.

5N번 양을 세면 0에서 9까지 모든 숫자를 보게 되므로 민석이는 양 세기를 멈춘다.

**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 N (1 ≤ N ≤ 106)이 주어진다.

**[출력]**

각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,

최소 몇 번 양을 세었을 때 이전에 봤던 숫자들의 자릿수에서 0에서 9까지의 모든 숫자를 보게 되는지 출력한다.

( 민석이는 xN번 양을 세고 있다. )

```python
T = int(input())

i = 0
n = []
result = []
while i < T:
    n_ele = int(input())
    n.append(n_ele)
    

    num = n[i]
    m = 1
    count_dict = {key:0 for key in range(10)}
    while True:
        count_number = num * m
        temp_list = [i for i in str(count_number)]
        for number in temp_list:
            count_dict[int(number)] += 1
        if all(count_dict.values()):
            break
        else:
            m += 1
    result.append(count_number)
    i += 1
   
for idx, i in enumerate(result):
    print(f'#{idx+1} {i}')
```

```
# input
5
1
2
11
1295
1692

# output
#1 10
#2 90
#3 110
#4 6475
#5 5076
```


# D4

## [S/W 문제해결 기본] 2일차 - Ladder1

점심 시간에 산책을 다니는 사원들은 최근 날씨가 더워져, 사다리 게임을 통하여 누가 아이스크림을 구입할지 결정하기로 한다.

김 대리는 사다리타기에 참여하지 않는 대신 사다리를 그리기로 하였다.

사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 X표시에 도착하게 되는지 궁금해졌다. 이를 구해보자.

아래 <그림 1>의 예를 살펴보면, 출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이 랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이 또한 랜덤하게 연결된다.

X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이, 아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.

방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.

문제의 X표시에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다. 해당 경로는 별도로 표시하였다.


![img](D4_1.assets/사다리01.jpg)

<그림 1> 사다리 게임에 대한 설명 (미니맵)


아래 <그림 2>와 같은 **100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서, 지정된 도착점에 대응되는 출발점 X를 반환하는 코드를 작성하라** (‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다. 도착 지점은 '2'로 표현된다).

 ![img](D4_1.assets/사다리02.jpg)

<그림 2> 테스트 케이스에 의해 생성되는 실제 사다리의 모습


**[제약 사항]**

한 막대에서 출발한 가로선이 다른 막대를 가로질러서 연속하여 이어지는 경우는 없다.

**[입력]**

입력 파일의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.

총 10개의 테스트 케이스가 주어진다.

**[출력]**

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 도착하게 되는 출발점의 x좌표를 출력한다.

```python
# 사다리 이동 로직
def move(ladder, point):
    row = point[0] - 1
    col = point[1]

    # 좌측 이동
    def moveleft(ladder, point):
        row = point[0]
        col = point[1] - 1

        while True:
            # 위쪽에 1이 있을 경우
            if ladder[row-1][col] == 1:
                return [row, col]

            col -= 1
    
    # 우측 이동
    def moveright(ladder, point):
        row = point[0]
        col = point[1] + 1
        
        while True:
            # 위쪽에 1이 있을 경우
            if ladder[row-1][col] == 1:
                return [row, col]
            
            col += 1

    while True:
        
        # 우측에 1이 있을 경우 moveright 함수로 이동
        if col != 99 and ladder[row][col+1] == 1:
            pos = moveright(ladder, [row, col])
            row, col = pos[0], pos[1]


        # 좌측에 1이 있을 경우 moveleft 함수로 이동
        elif col != 0 and ladder[row][col-1] == 1:
            pos = moveleft(ladder, [row, col])
            row, col = pos[0], pos[1]

        # 최상단에 도착한 경우
        elif row == 0:
            return [row, col]
        
        row -= 1


x = 0
while x < 10:
    T = int(input())

    # 사다리 리스트
    ladder = [list(map(int, input().split())) for _ in range(100)]

    # 도착 지점 위치
    goal = [99, 0]
    for i in range(100):
        if ladder[99][i] == 2:
            goal[1] = i
    
    # 사다리 이동 함수 (도착지점 -> 출발지점)
    point = move(ladder, goal)

    print(f'#{x+1} {point[1]}')

    x += 1
```

```
# input
1
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 ...
1 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 ...
1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 ...
...

# output
#1 67
...
```



## 3143. 가장 빠른 문자열 타이핑

어떤 문자열 A를 타이핑하려고 한다.

그냥 한 글자씩 타이핑 한다면 A의 길이만큼 키를 눌러야 할 것이다.

여기에 속도를 조금 더 높이기 위해 어떤 문자열 B가 저장되어 있어서 키를 한번 누른 것으로 B전체를 타이핑 할 수 있다.

이미 타이핑 한 문자를 지우는 것은 불가능하다.

예를 들어 A=”asakusa”, B=”sa”일 때, 다음 그림과 같이 B를 두 번 사용하면 5번 만에 A를 타이핑 할 수 있다.

![img](D4_1.assets/문자열타이핑01.jpg)

A와 B가 주어질 때 A 전체를 타이핑 하기 위해 키를 눌러야 하는 횟수의 최솟값을 구하여라.


**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스마다 첫 번째 줄에 두 문자열 A, B가 주어진다. A의 길이는 1이상 10,000이하, B의 길이는 1이상 100이하이다.


**[출력]**

각 테스트 케이스마다 A 전체를 타이핑 하기 위해 키를 눌러야 하는 횟수의 최솟값을 출력한다.

```python
T = int(input())
x = 0
while x < T:
    a, b = map(str, input().split())
    # a 문자열에서 b 문자열이 등장하는 횟수
    macro = a.count(b)

    # 타이핑 회수 계산
    # 전체 문자열 길이 - b 문자열의 반복 길이 + b 문자열 등장횟수
    result = len(a) - (len(b) * macro) + macro

    print('#{} {}'.format(x+1, result))
    x += 1
```

```
# input
2              //Test Case의 개수
banana bana    //A=”banana”, B=”bana”
asakusa sa	   //A=”asakusa”, B=”sa”

# output

#1 3    //Test Case 1번의 답
#2 5	//Test Case 2번의 답
```



## 5432. 쇠막대기 자르기

여러 개의 쇠막대기를 레이저로 절단하려고 한다.

효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다.

쇠막대기와 레이저의 배치는 다음 조건을 만족한다.

 - 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다.

 - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.

 - 각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.

 - 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.

아래 그림은 위 조건을 만족하는 예를 보여준다.

수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.

 ![img](D4_1.assets/쇠막대기01.jpg)

이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.

1. 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 “()” 으로 표현된다. 또한, 모든 “()”는 반드시 레이저를 표현한다.

2. 쇠막대기의 왼쪽 끝은 여는 괄호 ‘(’ 로, 오른쪽 끝은 닫힌 괄호 ‘)’ 로 표현된다.

위 예의 괄호 표현은 그림 위에 주어져 있다.

쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고,

이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다.

쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하라.


**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다.

**[출력]**

각 테스트 케이스마다 #T를 출력하고 한 칸을 띄운 후, 잘려진 조각의 총 개수를 출력한다.

```python
# 런타임 오류가 나와요 ㅠㅠ
# T = int(input())
# x = 0
# while x < T:
#     stick = input()
#
#     laser_idx = []
#     open_idx = []
#     close_idx = []
#
#     # 레이저, 막대기 시작, 막대기 끝 인덱스 분류
#     for i in range(len(stick)):
#         if stick[i] == '(' and stick[i + 1] == ')':
#             laser_idx.extend([i, i + 1])
#         elif stick[i] == '(':
#             open_idx.append(i)
#         elif stick[i] == ')' and i not in laser_idx:
#             close_idx.append(i)
#
#     # 막대기 시작, 끝 쌍 찾기
#     stick_idx = []
#     for i in range(len(open_idx) - 1, -1, -1):
#         for j in range(len(close_idx)):
#             if open_idx[i] < close_idx[j]:
#                 if open_idx[i] not in stick_idx and close_idx[j] not in stick_idx:
#                     stick_idx.extend([open_idx[i], close_idx[j]])
#
#     # 레이저로 잘린 막대기 수 구하기
#     total = 0
#     for i in range(0, len(stick_idx), 2):
#         cut = 0
#         for j in range(0, len(laser_idx)):
#             if stick_idx[i] < laser_idx[j] < stick_idx[i + 1]:
#                 cut += 1
#         total += cut // 2 + 1
#
#     print('#{} {}'.format(x + 1, total))
#     x += 1

T = int(input())
x = 0
while x < T:
    stick = input()

    layer = 0
    result = 0

    idx = 0
    while idx < len(stick):
        # 레이저
        if stick[idx] == '(' and stick[idx+1] == ')':
            result += layer

        # 막대기 시작
        elif stick[idx] == '(':
            layer += 1
            result += 1

        # 막대기 끝
        elif stick[idx] == ')' and stick[idx-1] == ')':
            layer -= 1

        idx += 1

    print('#{} {}'.format(x+1, result))
    x += 1
```

```
# input
2                           //전체 TC 개수
()(((()())(())()))(())      //첫 번째 TC
(((()(()()))(())()))(()())	//두 번째 TC

# output
#1 17   //첫 번째 TC의 출력
#2 24	//두 번째 TC의 출력
```


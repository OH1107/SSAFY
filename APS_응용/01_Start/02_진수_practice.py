# 16진수 문자로 이루어진 1차 배열이 주어질 때 앞에서부터 7bit씩 묶어 십진수로 변환하여 출력해 보자
# 예를 들어 0F97A3 일 경우
# 000011111001011110100011 -> 0000111 1100101 1110100 011
# 7, 101, 116, 3을 출력

# 입력 예
# 01D06079861D79F99F

a = input()

# 16진수 -> 2진수를 위한 해쉬코드
hcode = {'0': '0000', '1': '0001', '2': '0010', '3': '0011',
         '4': '0100', '5': '0101', '6': '0110', '7': '0111',
         '8': '1000', '9': '1001', 'A': '1010', 'B': '1011',
         'C': '1100', 'D': '1101', 'E': '1110', 'F': '1111'}

_digits = 0     # 자리수 계산을 위한 변수

while True:     # 우선 계속 반복

    binary = ''                 # 2진수로 변환하여 저장하기 위한 변수
    for demi in a:              # 16진수를 순회하며 해쉬코드에 맞는 2진수로 누적 저장
        binary += hcode[demi]

    tmp = binary[_digits:_digits + 7]   # 2진수를 7자리씩 묶어서 임시 할당

    add_zero = 0                # 7자리가 모자랄 경우 추가할 0의 갯수
    if len(tmp) < 7:            # tmp의 길이가 7자리보다 적을 경우 (마지막 슬라이싱에서 발생)
        add_zero = 7 - len(tmp) # 부족한 만큼 앞쪽으로 0을 추가
        tmp = ('0' * add_zero) + tmp

    res = 0                                 # 10진수를 저장하기 위한 변수
    for i in range(6, -1, -1):              # 2^0자리부터 순회하기 위한 역순 선언
        res += int(tmp[i]) * (2 ** (6 - i)) # i을 2^i에 해당하는 값으로 계산, 10진수 변수에 누적 합

    _digits += 7                            # 다음 7bit 자리수 계산을 위한 +7

    print(res, end=' ')                     # 현재 저장된 10진수 출력

    if add_zero:                            # 만약 7 자리가 안되서 추가한 적
        break                               # (마지막 슬라이싱을 다뤘으므로)이 있다면 종료

# 결과
# 0 116 12 7 76 24 58 121 124 103 3